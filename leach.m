function kOpt = clusterOptimum(netArch, nodeArch, dBS)
% calculate the optimum values for number of nodes
%
%   Input:
%       netArch     network model
%       nodeArch    nodes model
%       dBS         length from base station
%   Example:
%       dBS = sqrt(netArch.Sink.x ^ 2 + netArch.Sink.y ^ 2);
%       numClusters     = clusterOptimum(netArch, nodeArch, dBS);
%
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    N    = nodeArch.numNode; % number of nodes
    M    = sqrt(netArch.Yard.Length * netArch.Yard.Width);
    kOpt = sqrt(N) / sqrt(2*pi) * ...
           sqrt(netArch.Energy.freeSpace / netArch.Energy.multiPath) * ...
           M / dBS ^ 2;
    kOpt = round(kOpt);
end
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
function createfigure(X1, Y1, Y2, Y3)
%CREATEFIGURE(X1,Y1,Y2,Y3)
%  X1:  vector of x data
%  Y1:  vector of y data
%  Y2:  vector of y data
%  Y3:  vector of y data

%  Auto-generated by MATLAB on 31-Jan-2013 18:49:05

% Create figure
figure1 = figure(2);

% Create sub-plot
subplot1 = subplot(1,3,3,'Parent',figure1);
box(subplot1,'on');
hold(subplot1,'all');

% Create plot
plot(X1,Y1,'Parent',subplot1,'LineWidth',2,'Color',[0 1 0]);

% Create x-label
xlabel('Round','FontWeight','bold','FontSize',11,'FontName','Cambria');

% Create y-label
ylabel('sum of energy','FontWeight','bold','FontSize',11,...
    'FontName','Cambria');

% Create title
title('Sum of energy of nodes vs. round','FontWeight','bold','FontSize',12,...
    'FontName','Cambria');

% Create sub-plot
subplot2 = subplot(1,3,1,'Parent',figure1);
box(subplot2,'on');
hold(subplot2,'all');

% Create plot
plot(X1,Y2,'Parent',subplot2,'LineWidth',2);

% Create x-label
xlabel('Round','FontWeight','bold','FontSize',11,'FontName','Cambria');

% Create y-label
ylabel('# of packets sent to BS nodes','FontWeight','bold','FontSize',11,...
    'FontName','Cambria');

% Create title
title('Number of packet sent to BS vs. round','FontWeight','bold',...
    'FontSize',12,...
    'FontName','Cambria');

% Create sub-plot
subplot3 = subplot(1,3,2,'Parent',figure1);
box(subplot3,'on');
hold(subplot3,'all');

% Create plot
plot(X1,Y3,'Parent',subplot3,'LineWidth',2,'Color',[1 0 0]);

% Create x-label
xlabel('Round','FontWeight','bold','FontSize',11,'FontName','Cambria');

% Create y-label
ylabel('# of dead nodes','FontWeight','bold','FontSize',11,...
    'FontName','Cambria');

% Create title
title('Number of dead node vs. round','FontWeight','bold','FontSize',12,...
    'FontName','Cambria');

function clusterModel = dissEnergyCH(clusterModel, roundArch)
% Calculation of Energy dissipated for CHs
%   Input:
%       clusterModel     architecture of nodes, network
%       roundArch        round Architecture
%   Example:
%       r = 10; % round no = 10
%       clusterModel = newCluster(netArch, nodeArch, 'def', r);
%       clusterModel = dissEnergyCH(clusterModel);
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    nodeArch = clusterModel.nodeArch;
    netArch  = clusterModel.netArch;
    cluster  = clusterModel.clusterNode;
    
    d0 = sqrt(netArch.Energy.freeSpace / ...
              netArch.Energy.multiPath);
    if cluster.countCHs == 0
        return
    end
    n = length(cluster.no); % Number of CHs
    ETX = netArch.Energy.transfer;
    ERX = netArch.Energy.receive;
    EDA = netArch.Energy.aggr;
    Emp = netArch.Energy.multiPath;
    Efs = netArch.Energy.freeSpace;
    packetLength = roundArch.packetLength;
    ctrPacketLength = roundArch.ctrPacketLength;
    for i = 1:n
        chNo = cluster.no(i);
        distance = cluster.distance(i);
        energy = nodeArch.node(chNo).energy;
        % energy for aggregation the data + energy for transferring to BS
        if(distance >= d0)
             nodeArch.node(chNo).energy = energy - ...
                 ((ETX+EDA) * packetLength + Emp * packetLength * (distance ^ 4));
        else
             nodeArch.node(chNo).energy = energy - ...
                 ((ETX+EDA) * packetLength + Efs * packetLength * (distance ^ 2));
        end
        nodeArch.node(chNo).energy = nodeArch.node(chNo).energy - ...
            ctrPacketLength * ERX * round(nodeArch.numNode / clusterModel.numCluster);
    end
    
    clusterModel.nodeArch = nodeArch;
end
function clusterModel = dissEnergyNonCH(clusterModel, roundArch)
% Calculation of Energy dissipated for CHs
%   Input:
%       clusterModel     architecture of nodes, network
%       roundArch        round Architecture
%   Example:
%       r = 10; % round no = 10
%       clusterModel = newCluster(netArch, nodeArch, 'def', r);
%       clusterModel = dissEnergyCH(clusterModel);
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
    
    nodeArch = clusterModel.nodeArch;
    netArch  = clusterModel.netArch;
    cluster  = clusterModel.clusterNode;
    if cluster.countCHs == 0
        return
    end
    d0 = sqrt(netArch.Energy.freeSpace / ...
              netArch.Energy.multiPath);
    ETX = netArch.Energy.transfer;
    ERX = netArch.Energy.receive;
    EDA = netArch.Energy.aggr;
    Emp = netArch.Energy.multiPath;
    Efs = netArch.Energy.freeSpace;
    packetLength = roundArch.packetLength;
    ctrPacketLength = roundArch.ctrPacketLength;
    
    locAlive = find(~nodeArch.dead); % find the nodes that are alive
    for i = locAlive % search in alive nodes
        %find Associated CH for each normal node
        if strcmp(nodeArch.node(i).type, 'N') &&  ...
            nodeArch.node(i).energy > 0
            
            locNode = [nodeArch.node(i).x, nodeArch.node(i).y];
            countCH = length(clusterModel.clusterNode.no); % Number of CHs
            % calculate distance to each CH and find smallest distance
            [minDis, loc] = min(sqrt(sum((repmat(locNode, countCH, 1) - cluster.loc)' .^ 2)));
            minDisCH =  cluster.no(loc);
            
            if (minDis > d0)
                nodeArch.node(i).energy = nodeArch.node(i).energy - ...
                    ctrPacketLength * ETX + Emp * packetLength * (minDis ^ 4);
            else
                nodeArch.node(i).energy = nodeArch.node(i).energy - ...
                    ctrPacketLength * ETX + Efs * packetLength * (minDis ^ 2);
            end
            %Energy dissipated
            if(minDis > 0)
                nodeArch.node(minDisCH).energy = nodeArch.node(minDisCH).energy - ...
                    ((ERX + EDA) * packetLength );
            end
        end % if
    end % for
    clusterModel.nodeArch = nodeArch;
end
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
function fig(data, r, n, yLabel, Title)
% plot data vs. round

    figure(2);
    subplot(1, 3, n);
    plot(1:r, data);
    xlabel('Round');
    ylabel(yLabel);
    title(Title);
end
function clusterModel = newCluster(netArch, nodeArch, ...
                        clusterFun, clusterFunParam, p_numCluster)
% Create the network architecture with desired parameters
%   
%   Input:
%       clusterFun          Function name for clustering algorithm.
%       clusterFunParam     Parameters for the cluster function
%       numCluster          Number of clusters (CHs)
%       netArch             Network model
%       nodeArch            Nodes model
%   Example:
%       clusterModel = newCluster();
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    % set the parameters
    if ~exist('clusterFun','var')
        clusterFun = 'leach'; % default for clustering the node is leach algorithm
    end
    if strcmp(clusterFun, 'def')
        clusterFun = 'leach'; % default for clustering the node is leach algorithm
    end
    clusterModel.clusterFun = clusterFun;
   
    if ~exist('clusterFunParam','var')
        clusterFunParam = [];
    end
    clusterModel.clusterFunParam = clusterFunParam;
   
    if ~exist('netArch','var')
        netArch = newNetwork();
    end
    clusterModel.netArch = netArch;
    
    if ~exist('nodeArch','var')
        nodeArch = newNodes();
    end
    clusterModel.nodeArch = nodeArch;
    
    if ~exist('p_numCluster','var')
        dBS        = sqrt((netArch.Sink.x - netArch.Yard.Length) ^ 2 + ...
                          (netArch.Sink.y - netArch.Yard.Width) ^ 2);
        numCluster = clusterOptimum(netArch, nodeArch, dBS); 
        p = 1 / numCluster;
    else
        if p_numCluster < 1
            p = p_numCluster;
            numCluster = 1 / p;
        else
            numCluster = p_numCluster;
            p = 1 / numCluster;
        end
    end
    %p = Optimal Election Probability of a node to become cluster head
    clusterModel.numCluster = numCluster;
    clusterModel.p          = p;
    
    % run the clustering algorithm
    addpath Cluster % put the clustering algorithm in the cluster folder
    [nodeArch, clusterNode] = feval(clusterFun, clusterModel, clusterFunParam); % execute the cluster function
    
    clusterModel.nodeArch = nodeArch;       % new architecture of nodes
    clusterModel.clusterNode = clusterNode; % the CHs
end
function NetArch = newNetwork(Length, Width, sinkX, sinkY, initEnergy...
    , transEnergy, recEnergy, fsEnergy, mpEnergy, aggrEnergy)
% Create the network architecture with desired parameters
%   
%   Input:
%       Length      Length of the yard
%       Width       Width of the yard
%       sinkX       x coordination of base station
%       sinkY       y coordination of base station
%       initEnergy  Initial energy of each node
%       transEnergy Energy for transferring of each bit (ETX)
%       recEnergy   Energy for receiving of each bit (ETX)
%       fsEnergy    Energy of free space model
%       mpEnergy    Energy of multi path model
%       aggrEnergy  Data aggregation energy     
%   Example:
%       NetArch = createNetwork();
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    %%%% Create the yard
    Yard.Type = 'Rect'; % Rectangular
    if ~exist('Length','var')
        Yard.Length = 100; % default of the yard is 100 in x coordination
    else
        Yard.Length = Length;
    end
    if ~exist('Width','var')
        Yard.Width = 100; % default of the yard is 100 in y coordination
    else
        Yard.Width = Width;
    end
    
    %%%% Create base station
    % x and y Coordinates of the base station
    % default of the base station is in the centre of the yard
    if ~exist('sinkX','var')
        Sink.x = Yard.Length / 2;
    else
        Sink.x = sinkX;
    end
    if ~exist('sinkY','var')
        Sink.y = Yard.Width / 2;
    else
        Sink.y = sinkY;
    end

    %%%% Energy Model (all values in Joules)
    % Initial Energy
    if ~exist('initEnergy','var')
        Energy.init = 0.5; 
    else
        Energy.init = initEnergy; 
    end
    
    % Energy for transferring of each bit (ETX)
    if ~exist('transEnergy','var')
        Energy.transfer = 50*0.000000001;
    else
        Energy.transfer = transEnergy; 
    end
    if ~exist('recEnergy','var')
        Energy.receive = 50*0.000000001;
    else
        Energy.receive = recEnergy; 
    end
    
    % Transmit Amplifier types
    if ~exist('recEnergy','var')
        Energy.freeSpace = 10*0.000000000001;
    else
        Energy.freeSpace = fsEnergy; 
    end
    if ~exist('recEnergy','var')
        Energy.multiPath = 0.0013*0.000000000001;
    else
        Energy.multiPath = mpEnergy; 
    end
    
    %Data Aggregation Energy
    if ~exist('recEnergy','var')
        Energy.aggr = 5*0.000000001;
    else
        Energy.aggr = aggrEnergy; 
    end

    NetArch = struct('Yard',   Yard, ...
                     'Sink',   Sink, ...
                     'Energy', Energy);
end
function nodeArch = newNodes(netArch, numNode)
% Create the node model randomly
%   
%   Input:
%       netArch     Network architecture
%       numNode    Number of Nodes in the field
%   Output:
%       nodeArch    Nodes architecture
%       nodesLoc    Location of Nodes in the field
%   Example:
%       netArch  = createNetwork();
%       nodeArch = createNodes(netArch, 100)
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    
    if ~exist('netArch','var')
        netArch = newNetwork();
    end
    
    if ~exist('numNode','var')
        numNode = 100;
    end
    for i = 1:numNode
        % x coordination of node
        nodeArch.node(i).x      =   rand * netArch.Yard.Length;
        nodeArch.nodesLoc(i, 1) =   nodeArch.node(i).x;
        % y coordination of node
        nodeArch.node(i).y      =   rand * netArch.Yard.Width;
        nodeArch.nodesLoc(i, 2) =   nodeArch.node(i).y;
        % the flag which determines the value of the indicator function? Ci(t)
        nodeArch.node(i).G      =   0; 
        % initially there are no cluster heads, only nodes
        nodeArch.node(i).type   =   'N'; % 'N' = node (nun-CH)
        nodeArch.node(i).energy =   netArch.Energy.init;
        
        nodeArch.node(i).CH     = -1; % number of its CH ?
        nodeArch.dead(i)        = 0; % the node is alive
    end
    nodeArch.numNode = numNode; % Number of Nodes in the field
    nodeArch.numDead = 0; % number of dead nodes
end
function NetRound = newRound(numRound, packetLength, ctrPacketLength)
% Create the round architecture for specific parameters
%   
%   Input:
%       numRound            Number of rounds
%       packetLength        Length of packet that sent for CH to BS
%       ctrPacketLength     Length of packet that sent for nodes to CH
%   Example:
%       NetRound = newRound();
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014

    if ~exist('numRound','var')
        NetRound.numRound = 9999; % default of the maximum round is 9999
    else
        NetRound.numRound = numRound;
    end
    if ~exist('packetLength','var')
        NetRound.packetLength = 6400; % default of the packet length is 6400
    else
        NetRound.packetLength = packetLength;
    end
    if ~exist('ctrPacketLength','var')
        NetRound.ctrPacketLength = 200;
    else
        NetRound.ctrPacketLength = ctrPacketLength;
    end
end
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
figure(1), hold on
plot(nodeArch.nodesLoc(:, 1), nodeArch.nodesLoc(:, 2),...
    '.', 'MarkerSize',15);
plot(netArch.Sink.x, netArch.Sink.y,'o', ...
    'MarkerSize',8, 'MarkerFaceColor', 'g');
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
function par = plotResults(clusterModel, r, par)
    nodeArch = clusterModel.nodeArch;
    netArch = clusterModel.netArch;
    
    
    %%%%% number of packets sent from CHs to BS
    if r == 1
        par.packetToBS(r) = clusterModel.numCluster;
    else
        par.packetToBS(r) = par.packetToBS(r-1) + clusterModel.clusterNode.countCHs;
    end
    % Figure packet to BS
%     fig(par.packetToBS, r, 1, '# of packets sent to BS nodes', ...
%         'Number of packet sent to BS vs. round');
    
    %%%%% Number of dead neurons
    par.numDead(r) = nodeArch.numDead;
    % Figure number of dead node
%     fig(par.numDead, r, 2, '# of dead nodes', 'Number of dead node vs. round');
    
    %%%%% Energy
    par.energy(r) = 0;
    node = clusterModel.nodeArch;
    for i = find(~node.dead)
        if node.node(i).energy > 0
            par.energy(r) = par.energy(r) + node.node(i).energy;
        end
    end
%     fig(par.energy, r, 3, 'sum of energy', 'Sum of energy of nodes vs. round'); 
    
    createfigure(1:r, par.energy, par.packetToBS, par.numDead);
end
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
clc, clear all, close all

numNodes = 100; % number of nodes
p = 0.1;

netArch  = newNetwork(100, 100, 50, 175);
nodeArch = newNodes(netArch, numNodes);
roundArch = newRound();

plot1

par = struct;

for r = 1:roundArch.numRound
    r
    clusterModel = newCluster(netArch, nodeArch, 'leach', r, p);
    clusterModel = dissEnergyCH(clusterModel, roundArch);
    clusterModel = dissEnergyNonCH(clusterModel, roundArch);
    nodeArch     = clusterModel.nodeArch; % new node architecture after select CHs
    
    par = plotResults(clusterModel, r, par);
    if nodeArch.numDead == nodeArch.numNode
        break
    end
end


function [nodeArch, clusterNode] = leach(clusterModel, clusterFunParam)
% Create the new node architecture using leach algorithm in beginning 
%  of each round. This function is called by newCluster function.
%   
%   Input:
%       clusterModel        Cluster model by newCluster function
%       clusterFunParam     Parameters for the cluster function
%                   [r ]
%   Example:
%       [nodeArch, clusterNode] = feval('leach', clusterModel, clusterFunParam);
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
    
    nodeArch = clusterModel.nodeArch;
    netArch  = clusterModel.netArch;
    r = clusterFunParam(1); % round no
    p = clusterModel.p;
    N = nodeArch.numNode; % number of nodes
    
    %%%%%%%% reset the CH after numCluster round
    if (mod(r, clusterModel.numCluster) == 0)
        for i = 1:N
            nodeArch.node(i).G = 0; % not selected for CH
        end
    end
    
    %%%%%%%% Checking if there is a dead node
    locAlive = find(~nodeArch.dead); % find the nodes that are alive
    for i = locAlive
        if nodeArch.node(i).energy <= 0
            nodeArch.node(i).type = 'D';
            nodeArch.dead(i) = 1;
        else
            nodeArch.node(i).type = 'N';
        end
    end
    nodeArch.numDead = sum(nodeArch.dead);
    
    %%%%%%%% find the cluster head
    % define cluster structure
    clusterNode     = struct();
    %
    locAlive = find(~nodeArch.dead); % find the nodes that are alive
    countCHs = 0;
    for i = locAlive % search in alive nodes
        temp_rand = rand;
        if (nodeArch.node(i).G <= 0) && ...
           (temp_rand <= prob(r, p)) && ...
           (nodeArch.node(i).energy > 0)

            countCHs = countCHs+1;

            nodeArch.node(i).type          = 'C';
            nodeArch.node(1,1).G           = round(1/p)-1;
            clusterNode.no(countCHs)       = i; % the no of node
            xLoc = nodeArch.node(i).x; % x location of CH
            yLoc = nodeArch.node(i).y; % y location of CH
            clusterNode.loc(countCHs, 1)   = xLoc;
            clusterNode.loc(countCHs, 2)   = yLoc;
            % Calculate distance of CH from BS
            clusterNode.distance(countCHs) = sqrt((xLoc - netArch.Sink.x)^2 + ...
                                                  (yLoc - netArch.Sink.y)^2);            
        end % if
    end % for
    clusterNode.countCHs = countCHs;
end
function P = prob(r, p)
% Probability function for elect the node as CH
%   Input:
%       r     round no
%       p     p?
%   Example:
%       P = prob(1, 0.1);
%
% Mohammad Hossein Homaei, Homaei@wsnlab.org & Homaei@wsnlab.ir
% Ver 1. 10/2014
%
    if ~exist('p','var')
        p = 0.1;
    end
    
    P = p / (1-p * mod(r, round(1 / p)));
end
